import z from 'zod';
import { CID } from 'multiformats';
import { ReadableBlockstore } from '../storage';
import { DataStore } from '../types';
import { BlockWriter } from '@ipld/car/api';
import BlockMap from '../block-map';
import CidSet from '../cid-set';
declare const nodeData: z.ZodObject<{
    l: z.ZodNullable<z.ZodEffects<z.ZodEffects<z.ZodAny, any, any>, CID, any>>;
    e: z.ZodArray<z.ZodObject<{
        p: z.ZodNumber;
        k: z.ZodType<Uint8Array, z.ZodTypeDef, Uint8Array>;
        v: z.ZodEffects<z.ZodEffects<z.ZodAny, any, any>, CID, any>;
        t: z.ZodNullable<z.ZodEffects<z.ZodEffects<z.ZodAny, any, any>, CID, any>>;
    }, "strip", z.ZodTypeAny, {
        p: number;
        k: Uint8Array;
        v: CID;
        t: CID | null;
    }, {
        v?: any;
        t?: any;
        p: number;
        k: Uint8Array;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    l: CID | null;
    e: {
        p: number;
        k: Uint8Array;
        v: CID;
        t: CID | null;
    }[];
}, {
    l?: any;
    e: {
        v?: any;
        t?: any;
        p: number;
        k: Uint8Array;
    }[];
}>;
export declare type NodeData = z.infer<typeof nodeData>;
export declare const nodeDataDef: {
    name: string;
    schema: z.ZodObject<{
        l: z.ZodNullable<z.ZodEffects<z.ZodEffects<z.ZodAny, any, any>, CID, any>>;
        e: z.ZodArray<z.ZodObject<{
            p: z.ZodNumber;
            k: z.ZodType<Uint8Array, z.ZodTypeDef, Uint8Array>;
            v: z.ZodEffects<z.ZodEffects<z.ZodAny, any, any>, CID, any>;
            t: z.ZodNullable<z.ZodEffects<z.ZodEffects<z.ZodAny, any, any>, CID, any>>;
        }, "strip", z.ZodTypeAny, {
            p: number;
            k: Uint8Array;
            v: CID;
            t: CID | null;
        }, {
            v?: any;
            t?: any;
            p: number;
            k: Uint8Array;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        l: CID | null;
        e: {
            p: number;
            k: Uint8Array;
            v: CID;
            t: CID | null;
        }[];
    }, {
        l?: any;
        e: {
            v?: any;
            t?: any;
            p: number;
            k: Uint8Array;
        }[];
    }>;
};
export declare type NodeEntry = MST | Leaf;
export declare type MstOpts = {
    layer: number;
};
export declare class MST implements DataStore {
    storage: ReadableBlockstore;
    entries: NodeEntry[] | null;
    layer: number | null;
    pointer: CID;
    outdatedPointer: boolean;
    constructor(storage: ReadableBlockstore, pointer: CID, entries: NodeEntry[] | null, layer: number | null);
    static create(storage: ReadableBlockstore, entries?: NodeEntry[], opts?: Partial<MstOpts>): Promise<MST>;
    static fromData(storage: ReadableBlockstore, data: NodeData, opts?: Partial<MstOpts>): Promise<MST>;
    static load(storage: ReadableBlockstore, cid: CID, opts?: Partial<MstOpts>): MST;
    newTree(entries: NodeEntry[]): Promise<MST>;
    getEntries(): Promise<NodeEntry[]>;
    getPointer(): Promise<CID>;
    getLayer(): Promise<number>;
    attemptGetLayer(): Promise<number | null>;
    getUnstoredBlocks(): Promise<{
        root: CID;
        blocks: BlockMap;
    }>;
    add(key: string, value: CID, knownZeros?: number): Promise<MST>;
    get(key: string): Promise<CID | null>;
    update(key: string, value: CID): Promise<MST>;
    delete(key: string): Promise<MST>;
    deleteRecurse(key: string): Promise<MST>;
    updateEntry(index: number, entry: NodeEntry): Promise<MST>;
    removeEntry(index: number): Promise<MST>;
    append(entry: NodeEntry): Promise<MST>;
    prepend(entry: NodeEntry): Promise<MST>;
    atIndex(index: number): Promise<NodeEntry | null>;
    slice(start?: number | undefined, end?: number | undefined): Promise<NodeEntry[]>;
    spliceIn(entry: NodeEntry, index: number): Promise<MST>;
    replaceWithSplit(index: number, left: MST | null, leaf: Leaf, right: MST | null): Promise<MST>;
    trimTop(): Promise<MST>;
    splitAround(key: string): Promise<[MST | null, MST | null]>;
    appendMerge(toMerge: MST): Promise<MST>;
    createChild(): Promise<MST>;
    createParent(): Promise<MST>;
    findGtOrEqualLeafIndex(key: string): Promise<number>;
    walkLeavesFrom(key: string): AsyncIterable<Leaf>;
    list(count?: number, after?: string, before?: string): Promise<Leaf[]>;
    listWithPrefix(prefix: string, count?: number): Promise<Leaf[]>;
    walk(): AsyncIterable<NodeEntry>;
    paths(): Promise<NodeEntry[][]>;
    allNodes(): Promise<NodeEntry[]>;
    allCids(): Promise<CidSet>;
    leaves(): Promise<Leaf[]>;
    leafCount(): Promise<number>;
    walkReachable(): AsyncIterable<NodeEntry>;
    reachableLeaves(): Promise<Leaf[]>;
    writeToCarStream(car: BlockWriter): Promise<void>;
    cidsForPath(key: string): Promise<CID[]>;
    isTree(): this is MST;
    isLeaf(): this is Leaf;
    equals(other: NodeEntry): Promise<boolean>;
}
export declare class Leaf {
    key: string;
    value: CID;
    constructor(key: string, value: CID);
    isTree(): this is MST;
    isLeaf(): this is Leaf;
    equals(entry: NodeEntry): boolean;
}
export default MST;
