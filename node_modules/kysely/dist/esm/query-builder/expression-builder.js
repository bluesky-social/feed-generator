/// <reference types="./expression-builder.d.ts" />
import { SelectQueryBuilder } from './select-query-builder.js';
import { SelectQueryNode } from '../operation-node/select-query-node.js';
import { parseTableExpressionOrList, } from '../parser/table-parser.js';
import { WithSchemaPlugin } from '../plugin/with-schema/with-schema-plugin.js';
import { createQueryId } from '../util/query-id.js';
import { FunctionModule } from './function-module.js';
import { parseStringReference, } from '../parser/reference-parser.js';
import { RawBuilder } from '../raw-builder/raw-builder.js';
import { freeze } from '../util/object-utils.js';
import { RawNode } from '../operation-node/raw-node.js';
export class ExpressionBuilder {
    #props;
    constructor(props) {
        this.#props = freeze(props);
    }
    /**
     * Returns a {@link FunctionModule} that can be used to write type safe function
     * calls.
     *
     * The difference between this and {@link Kysely.fn} is that this one is more
     * type safe. You can only refer to columns visible to the part of the query
     * you are building. {@link Kysely.fn} allows you to refer to columns in any
     * table of the database even if it doesn't produce valid SQL.
     *
     * ```ts
     * await db.selectFrom('person')
     *   .innerJoin('pet', 'pet.owner_id', 'person.id')
     *   .select([
     *     'person.id',
     *     (qb) => qb.fn.count('pet.id').as('pet_count')
     *   ])
     *   .groupBy('person.id')
     *   .having(count('pet.id'), '>', 10)
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "person"."id", count("pet"."id") as "pet_count"
     * from "person"
     * inner join "pet" on "pet"."owner_id" = "person"."id"
     * group by "person"."id"
     * having count("pet"."id") > $1
     * ```
     */
    get fn() {
        return new FunctionModule();
    }
    selectFrom(table) {
        return new SelectQueryBuilder({
            queryId: createQueryId(),
            executor: this.#props.executor,
            queryNode: SelectQueryNode.create(parseTableExpressionOrList(table)),
        });
    }
    /**
     * See {@link QueryCreator.withSchema}
     */
    withSchema(schema) {
        return new ExpressionBuilder({
            ...this.#props,
            executor: this.#props.executor.withPluginAtFront(new WithSchemaPlugin(schema)),
        });
    }
    /**
     * This can be used to reference columns.
     *
     * ### Examples
     *
     * In the next example we use the `ref` method to reference
     * columns of the virtual table `excluded` in a type-safe way
     * to create an upsert operation:
     *
     * ```ts
     * db.insertInto('person')
     *   .values(person)
     *   .onConflict(oc => oc
     *     .column('id')
     *     .doUpdateSet({
     *       first_name: (eb) => eb.ref('excluded.first_name'),
     *       last_name: (eb) => eb.ref('excluded.last_name')
     *     })
     *   )
     * ```
     *
     * In the next example we use `ref` in a raw sql expression. Unless you
     * want to be as type-safe as possible, this is probably overkill:
     *
     * ```ts
     * db.update('pet').set({
     *   name: (eb) => sql`concat(${eb.ref('pet.name')}, ${suffix})`
     * })
     * ```
     */
    ref(reference) {
        return new RawBuilder({
            queryId: createQueryId(),
            plugins: this.#props.executor.plugins,
            rawNode: RawNode.createWithChild(parseStringReference(reference)),
        });
    }
}
