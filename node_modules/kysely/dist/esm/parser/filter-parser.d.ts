import { FilterNode } from '../operation-node/filter-node.js';
import { AnyRawBuilder } from '../util/type-utils.js';
import { Operator } from '../operation-node/operator-node.js';
import { ExtractTypeFromReferenceExpression, ReferenceExpression } from './reference-parser.js';
import { ValueExpression, ValueExpressionOrList } from './value-parser.js';
import { FilterExpressionNode } from '../operation-node/operation-node-utils.js';
import { WhereInterface } from '../query-builder/where-interface.js';
import { HavingInterface } from '../query-builder/having-interface.js';
import { ComplexExpression } from './complex-expression-parser.js';
export declare type FilterValueExpression<DB, TB extends keyof DB, RE> = ValueExpression<DB, TB, ExtractTypeFromReferenceExpression<DB, TB, RE>>;
export declare type FilterValueExpressionOrList<DB, TB extends keyof DB, RE> = ValueExpressionOrList<DB, TB, ExtractTypeFromReferenceExpression<DB, TB, RE>>;
export declare type ExistsExpression<DB, TB extends keyof DB> = ComplexExpression<DB, TB, any>;
export declare type WhereGrouper<DB, TB extends keyof DB> = (qb: WhereInterface<DB, TB>) => WhereInterface<DB, TB>;
export declare type HavingGrouper<DB, TB extends keyof DB> = (qb: HavingInterface<DB, TB>) => HavingInterface<DB, TB>;
export declare type FilterOperator = Operator | AnyRawBuilder;
declare type FilterType = 'where' | 'having' | 'on';
export declare function parseWhereFilter(args: any[]): FilterExpressionNode;
export declare function parseHavingFilter(args: any[]): FilterExpressionNode;
export declare function parseOnFilter(args: any[]): FilterExpressionNode;
export declare function parseReferenceFilter(lhs: ReferenceExpression<any, any>, op: FilterOperator, rhs: ReferenceExpression<any, any>): FilterNode;
export declare function parseExistFilter(arg: ExistsExpression<any, any>): FilterNode;
export declare function parseNotExistFilter(arg: ExistsExpression<any, any>): FilterNode;
export declare function parseFilter(type: FilterType, args: any[]): FilterExpressionNode;
export {};
