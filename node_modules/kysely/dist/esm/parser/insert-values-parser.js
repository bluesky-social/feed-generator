/// <reference types="./insert-values-parser.d.ts" />
import { ColumnNode } from '../operation-node/column-node.js';
import { PrimitiveValueListNode } from '../operation-node/primitive-value-list-node.js';
import { ValueListNode } from '../operation-node/value-list-node.js';
import { freeze, isUndefined } from '../util/object-utils.js';
import { parseValueExpression } from './value-parser.js';
import { ValuesNode } from '../operation-node/values-node.js';
import { isComplexExpression } from './complex-expression-parser.js';
import { DefaultInsertValueNode } from '../operation-node/default-insert-value-node.js';
export function parseInsertObjectOrList(args) {
    return parseInsertColumnsAndValues(Array.isArray(args) ? args : [args]);
}
function parseInsertColumnsAndValues(rows) {
    const columns = parseColumnNamesAndIndexes(rows);
    return [
        freeze([...columns.keys()].map(ColumnNode.create)),
        ValuesNode.create(rows.map((row) => parseRowValues(row, columns))),
    ];
}
function parseColumnNamesAndIndexes(rows) {
    const columns = new Map();
    for (const row of rows) {
        const cols = Object.keys(row);
        for (const col of cols) {
            if (!columns.has(col) && row[col] !== undefined) {
                columns.set(col, columns.size);
            }
        }
    }
    return columns;
}
function parseRowValues(row, columns) {
    const rowColumns = Object.keys(row);
    const rowValues = Array.from({
        length: columns.size,
    });
    let complexColumn = false;
    for (const col of rowColumns) {
        const columnIdx = columns.get(col);
        if (columnIdx !== undefined) {
            const value = row[col];
            if (isComplexExpression(value)) {
                complexColumn = true;
            }
            rowValues[columnIdx] = value;
        }
    }
    const columnMissing = rowColumns.length < columns.size;
    if (columnMissing || complexColumn) {
        const defaultValue = DefaultInsertValueNode.create();
        return ValueListNode.create(rowValues.map((it) => isUndefined(it) ? defaultValue : parseValueExpression(it)));
    }
    return PrimitiveValueListNode.create(rowValues);
}
