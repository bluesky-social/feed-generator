/// <reference types="./filter-parser.d.ts" />
import { FilterNode } from '../operation-node/filter-node.js';
import { freeze, isBoolean, isFunction, isNull, isString, } from '../util/object-utils.js';
import { isOperationNodeSource } from '../operation-node/operation-node-source.js';
import { RawNode } from '../operation-node/raw-node.js';
import { OperatorNode, OPERATORS, } from '../operation-node/operator-node.js';
import { ParensNode } from '../operation-node/parens-node.js';
import { parseReferenceExpression, } from './reference-parser.js';
import { parseValueExpressionOrList, } from './value-parser.js';
import { ValueNode } from '../operation-node/value-node.js';
import { createJoinBuilder, createSelectQueryBuilder } from './parse-utils.js';
export function parseWhereFilter(args) {
    return parseFilter('where', args);
}
export function parseHavingFilter(args) {
    return parseFilter('having', args);
}
export function parseOnFilter(args) {
    return parseFilter('on', args);
}
export function parseReferenceFilter(lhs, op, rhs) {
    return FilterNode.create(parseReferenceExpression(lhs), parseFilterOperator(op), parseReferenceExpression(rhs));
}
export function parseExistFilter(arg) {
    return parseExistExpression('exists', arg);
}
export function parseNotExistFilter(arg) {
    return parseExistExpression('not exists', arg);
}
export function parseFilter(type, args) {
    if (args.length === 3) {
        return parseThreeArgFilter(args[0], args[1], args[2]);
    }
    else if (args.length === 1) {
        return parseOneArgFilter(type, args[0]);
    }
    throw createFilterError(type, args);
}
function parseThreeArgFilter(left, op, right) {
    if ((op === 'is' || op === 'is not') && (isNull(right) || isBoolean(right))) {
        return parseIsFilter(left, op, right);
    }
    return FilterNode.create(parseReferenceExpression(left), parseFilterOperator(op), parseValueExpressionOrList(right));
}
function parseIsFilter(left, op, right) {
    return FilterNode.create(parseReferenceExpression(left), parseFilterOperator(op), ValueNode.createImmediate(right));
}
function parseFilterOperator(op) {
    if (isString(op) && OPERATORS.includes(op)) {
        return OperatorNode.create(op);
    }
    else if (isOperationNodeSource(op)) {
        return op.toOperationNode();
    }
    throw new Error(`invalid comparison operator ${JSON.stringify(op)} passed to a filter method`);
}
function parseExistExpression(type, arg) {
    return FilterNode.create(undefined, OperatorNode.create(type), parseValueExpressionOrList(arg));
}
function parseOneArgFilter(type, arg) {
    if (isFunction(arg)) {
        return GROUP_PARSERS[type](arg);
    }
    else if (isOperationNodeSource(arg)) {
        const node = arg.toOperationNode();
        if (RawNode.is(node)) {
            return node;
        }
    }
    throw createFilterError(type, arg);
}
function createFilterError(type, args) {
    return new Error(`invalid arguments passed to a '${type}' method: ${JSON.stringify(args)}`);
}
const GROUP_PARSERS = freeze({
    where(callback) {
        const query = callback(createSelectQueryBuilder());
        const queryNode = query.toOperationNode();
        if (!queryNode.where) {
            throw new Error('no `where` methods called insided a group callback');
        }
        return ParensNode.create(queryNode.where.where);
    },
    having(callback) {
        const query = callback(createSelectQueryBuilder());
        const queryNode = query.toOperationNode();
        if (!queryNode.having) {
            throw new Error('no `having` methods called insided a group callback');
        }
        return ParensNode.create(queryNode.having.having);
    },
    on(callback) {
        const joinBuilder = callback(createJoinBuilder('InnerJoin', 'table'));
        const joinNode = joinBuilder.toOperationNode();
        if (!joinNode.on) {
            throw new Error('no `on` methods called insided a group callback');
        }
        return ParensNode.create(joinNode.on.on);
    },
});
