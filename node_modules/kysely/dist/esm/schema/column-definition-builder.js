/// <reference types="./column-definition-builder.d.ts" />
import { CheckConstraintNode } from '../operation-node/check-constraint-node.js';
import { ReferenceNode } from '../operation-node/reference-node.js';
import { ReferencesNode, } from '../operation-node/references-node.js';
import { SelectAllNode } from '../operation-node/select-all-node.js';
import { parseStringReference } from '../parser/reference-parser.js';
import { preventAwait } from '../util/prevent-await.js';
import { ColumnDefinitionNode } from '../operation-node/column-definition-node.js';
import { parseDefaultValueExpression, } from '../parser/default-value-parser.js';
import { GeneratedNode } from '../operation-node/generated-node.js';
import { DefaultValueNode } from '../operation-node/default-value-node.js';
import { parseOnModifyForeignAction } from '../parser/on-modify-action-parser.js';
export class ColumnDefinitionBuilder {
    #node;
    constructor(node) {
        this.#node = node;
    }
    autoIncrement() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { autoIncrement: true }));
    }
    primaryKey() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { primaryKey: true }));
    }
    references(ref) {
        const references = parseStringReference(ref);
        if (!ReferenceNode.is(references) || SelectAllNode.is(references.column)) {
            throw new Error(`invalid call references('${ref}'). The reference must have format table.column or schema.table.column`);
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            references: ReferencesNode.create(references.table, [
                references.column,
            ]),
        }));
    }
    onDelete(onDelete) {
        if (!this.#node.references) {
            throw new Error('on delete constraint can only be added for foreign keys');
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            references: ReferencesNode.cloneWithOnDelete(this.#node.references, parseOnModifyForeignAction(onDelete)),
        }));
    }
    onUpdate(onUpdate) {
        if (!this.#node.references) {
            throw new Error('on update constraint can only be added for foreign keys');
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            references: ReferencesNode.cloneWithOnUpdate(this.#node.references, parseOnModifyForeignAction(onUpdate)),
        }));
    }
    unique() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unique: true }));
    }
    notNull() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { notNull: true }));
    }
    unsigned() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, { unsigned: true }));
    }
    defaultTo(value) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            defaultTo: DefaultValueNode.create(parseDefaultValueExpression(value)),
        }));
    }
    check(expression) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            check: CheckConstraintNode.create(expression.toOperationNode()),
        }));
    }
    generatedAlwaysAs(expression) {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.createWithExpression(expression.toOperationNode()),
        }));
    }
    generatedAlwaysAsIdentity() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.create({ identity: true, always: true }),
        }));
    }
    generatedByDefaultAsIdentity() {
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.create({ identity: true, byDefault: true }),
        }));
    }
    stored() {
        if (!this.#node.generated) {
            throw new Error('stored() can only be called after generatedAlwaysAs');
        }
        return new ColumnDefinitionBuilder(ColumnDefinitionNode.cloneWith(this.#node, {
            generated: GeneratedNode.cloneWith(this.#node.generated, {
                stored: true,
            }),
        }));
    }
    toOperationNode() {
        return this.#node;
    }
}
preventAwait(ColumnDefinitionBuilder, "don't await ColumnDefinitionBuilder instances directly.");
