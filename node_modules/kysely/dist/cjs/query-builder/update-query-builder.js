"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.UpdateQueryBuilder = void 0;
const join_parser_js_1 = require("../parser/join-parser.js");
const table_parser_js_1 = require("../parser/table-parser.js");
const select_parser_js_1 = require("../parser/select-parser.js");
const filter_parser_js_1 = require("../parser/filter-parser.js");
const query_node_js_1 = require("../operation-node/query-node.js");
const update_query_node_js_1 = require("../operation-node/update-query-node.js");
const update_set_parser_js_1 = require("../parser/update-set-parser.js");
const prevent_await_js_1 = require("../util/prevent-await.js");
const object_utils_js_1 = require("../util/object-utils.js");
const update_result_js_1 = require("./update-result.js");
const no_result_error_js_1 = require("./no-result-error.js");
const explain_node_js_1 = require("../operation-node/explain-node.js");
class UpdateQueryBuilder {
    #props;
    constructor(props) {
        this.#props = (0, object_utils_js_1.freeze)(props);
    }
    where(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithWhere(this.#props.queryNode, (0, filter_parser_js_1.parseWhereFilter)(args)),
        });
    }
    whereRef(lhs, op, rhs) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithWhere(this.#props.queryNode, (0, filter_parser_js_1.parseReferenceFilter)(lhs, op, rhs)),
        });
    }
    orWhere(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithOrWhere(this.#props.queryNode, (0, filter_parser_js_1.parseWhereFilter)(args)),
        });
    }
    orWhereRef(lhs, op, rhs) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithOrWhere(this.#props.queryNode, (0, filter_parser_js_1.parseReferenceFilter)(lhs, op, rhs)),
        });
    }
    whereExists(arg) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithWhere(this.#props.queryNode, (0, filter_parser_js_1.parseExistFilter)(arg)),
        });
    }
    whereNotExists(arg) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithWhere(this.#props.queryNode, (0, filter_parser_js_1.parseNotExistFilter)(arg)),
        });
    }
    orWhereExists(arg) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithOrWhere(this.#props.queryNode, (0, filter_parser_js_1.parseExistFilter)(arg)),
        });
    }
    orWhereNotExists(arg) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithOrWhere(this.#props.queryNode, (0, filter_parser_js_1.parseNotExistFilter)(arg)),
        });
    }
    from(from) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: update_query_node_js_1.UpdateQueryNode.cloneWithFromItems(this.#props.queryNode, (0, table_parser_js_1.parseTableExpressionOrList)(from)),
        });
    }
    innerJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithJoin(this.#props.queryNode, (0, join_parser_js_1.parseJoin)('InnerJoin', args)),
        });
    }
    leftJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithJoin(this.#props.queryNode, (0, join_parser_js_1.parseJoin)('LeftJoin', args)),
        });
    }
    rightJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithJoin(this.#props.queryNode, (0, join_parser_js_1.parseJoin)('RightJoin', args)),
        });
    }
    fullJoin(...args) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithJoin(this.#props.queryNode, (0, join_parser_js_1.parseJoin)('FullJoin', args)),
        });
    }
    /**
     * Sets the values to update for an {@link Kysely.updateTable | update} query.
     *
     * This method takes an object whose keys are column names and values are
     * values to update. In addition to the column's type, the values can be
     * raw {@link sql} snippets or select queries.
     *
     * The return value of an update query is an instance of {@link UpdateResult}.
     * You can use the {@link returning} method on supported databases to get out
     * the updated rows.
     *
     * ### Examples
     *
     * Update a row in `person` table:
     *
     * ```ts
     * const result = await db
     *   .updateTable('person')
     *   .set({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston'
     *   })
     *   .where('id', '=', 1)
     *   .executeTakeFirst()
     *
     * console.log(result.numUpdatedRows)
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * update "person" set "first_name" = $1, "last_name" = $2 where "id" = $3
     * ```
     *
     * On PostgreSQL you ca chain `returning` to the query to get
     * the updated rows' columns (or any other expression) as the
     * return value:
     *
     * ```ts
     * const row = await db
     *   .updateTable('person')
     *   .set({
     *     first_name: 'Jennifer',
     *     last_name: 'Aniston'
     *   })
     *   .where('id', '=', 1)
     *   .returning('id')
     *   .executeTakeFirstOrThrow()
     *
     * row.id
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * update "person" set "first_name" = $1, "last_name" = $2 where "id" = $3 returning "id"
     * ```
     *
     * In addition to primitives, the values can also be raw sql expressions or
     * select queries:
     *
     * ```ts
     * import { sql } from 'kysely'
     *
     * const result = await db
     *   .updateTable('person')
     *   .set({
     *     first_name: 'Jennifer',
     *     last_name: sql`${'Ani'} || ${'ston'}`,
     *     age: db.selectFrom('person').select(sql`avg(age)`),
     *   })
     *   .where('id', '=', 1)
     *   .executeTakeFirst()
     *
     * console.log(result.numUpdatedRows)
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * update "person" set
     * "first_name" = $1,
     * "last_name" = $2 || $3,
     * "age" = (select avg(age) from "person")
     * where "id" = $4
     * ```
     */
    set(row) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: update_query_node_js_1.UpdateQueryNode.cloneWithUpdates(this.#props.queryNode, (0, update_set_parser_js_1.parseUpdateObject)(row)),
        });
    }
    returning(selection) {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithReturning(this.#props.queryNode, (0, select_parser_js_1.parseSelectExpressionOrList)(selection)),
        });
    }
    returningAll() {
        return new UpdateQueryBuilder({
            ...this.#props,
            queryNode: query_node_js_1.QueryNode.cloneWithReturning(this.#props.queryNode, (0, select_parser_js_1.parseSelectAll)()),
        });
    }
    /**
     * Simply calls the given function passing `this` as the only argument.
     *
     * If you want to conditionally call a method on `this`, see
     * the {@link if} method.
     *
     * ### Examples
     *
     * The next example uses a helper funtion `log` to log a query:
     *
     * ```ts
     * function log<T extends Compilable>(qb: T): T {
     *   console.log(qb.compile())
     *   return qb
     * }
     *
     * db.updateTable('person')
     *   .set(values)
     *   .call(log)
     *   .execute()
     * ```
     */
    call(func) {
        return func(this);
    }
    /**
     * Call `func(this)` if `condition` is true.
     *
     * This method is especially handy with optional selects. Any `returning` or `returningAll`
     * method calls add columns as optional fields to the output type when called inside
     * the `func` callback. This is because we can't know if those selections were actually
     * made before running the code.
     *
     * You can also call any other methods inside the callback.
     *
     * ### Examples
     *
     * ```ts
     * async function updatePerson(id: number, updates: UpdateablePerson, returnLastName: boolean) {
     *   return await db
     *     .updateTable('person')
     *     .set(updates)
     *     .where('id', '=', id)
     *     .returning(['id', 'first_name'])
     *     .if(returnLastName, (qb) => qb.returning('last_name'))
     *     .executeTakeFirstOrThrow()
     * }
     * ```
     *
     * Any selections added inside the `if` callback will be added as optional fields to the
     * output type since we can't know if the selections were actually made before running
     * the code. In the example above the return type of the `updatePerson` function is:
     *
     * ```ts
     * {
     *   id: number
     *   first_name: string
     *   last_name?: string
     * }
     * ```
     */
    if(condition, func) {
        if (condition) {
            return func(this);
        }
        return new UpdateQueryBuilder({
            ...this.#props,
        });
    }
    /**
     * Change the output type of the query.
     *
     * You should only use this method as the last resort if the types
     * don't support your use case.
     */
    castTo() {
        return new UpdateQueryBuilder(this.#props);
    }
    /**
     * Returns a copy of this UpdateQueryBuilder instance with the given plugin installed.
     */
    withPlugin(plugin) {
        return new UpdateQueryBuilder({
            ...this.#props,
            executor: this.#props.executor.withPlugin(plugin),
        });
    }
    toOperationNode() {
        return this.#props.executor.transformQuery(this.#props.queryNode, this.#props.queryId);
    }
    compile() {
        return this.#props.executor.compileQuery(this.toOperationNode(), this.#props.queryId);
    }
    /**
     * Executes the query and returns an array of rows.
     *
     * Also see the {@link executeTakeFirst} and {@link executeTakeFirstOrThrow} methods.
     */
    async execute() {
        const compildQuery = this.compile();
        const query = compildQuery.query;
        const result = await this.#props.executor.executeQuery(compildQuery, this.#props.queryId);
        if (this.#props.executor.adapter.supportsReturning && query.returning) {
            return result.rows;
        }
        else {
            return [new update_result_js_1.UpdateResult(result.numUpdatedOrDeletedRows)];
        }
    }
    /**
     * Executes the query and returns the first result or undefined if
     * the query returned no result.
     */
    async executeTakeFirst() {
        const [result] = await this.execute();
        return result;
    }
    /**
     * Executes the query and returns the first result or throws if
     * the query returned no result.
     *
     * By default an instance of {@link NoResultError} is thrown, but you can
     * provide a custom error class as the only argument to throw a different
     * error.
     */
    async executeTakeFirstOrThrow(errorConstructor = no_result_error_js_1.NoResultError) {
        const result = await this.executeTakeFirst();
        if (result === undefined) {
            throw new errorConstructor(this.toOperationNode());
        }
        return result;
    }
    /**
     * Executes query with `explain` statement before `update` keyword.
     *
     * ```ts
     * const explained = await db
     *  .updateTable('person')
     *  .set(updates)
     *  .where('id', '=', 123)
     *  .explain('json')
     * ```
     *
     * The generated SQL (MySQL):
     *
     * ```sql
     * explain format=json update `person` set `first_name` = ?, `last_name` = ? where `id` = ?
     * ```
     */
    async explain(format, options) {
        const builder = new UpdateQueryBuilder({
            ...this.#props,
            queryNode: update_query_node_js_1.UpdateQueryNode.cloneWithExplain(this.#props.queryNode, explain_node_js_1.ExplainNode.create(format, options)),
        });
        return await builder.execute();
    }
}
exports.UpdateQueryBuilder = UpdateQueryBuilder;
(0, prevent_await_js_1.preventAwait)(UpdateQueryBuilder, "don't await UpdateQueryBuilder instances directly. To execute the query you need to call `execute` or `executeTakeFirst`.");
