"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ExpressionBuilder = void 0;
const select_query_builder_js_1 = require("./select-query-builder.js");
const select_query_node_js_1 = require("../operation-node/select-query-node.js");
const table_parser_js_1 = require("../parser/table-parser.js");
const with_schema_plugin_js_1 = require("../plugin/with-schema/with-schema-plugin.js");
const query_id_js_1 = require("../util/query-id.js");
const function_module_js_1 = require("./function-module.js");
const reference_parser_js_1 = require("../parser/reference-parser.js");
const raw_builder_js_1 = require("../raw-builder/raw-builder.js");
const object_utils_js_1 = require("../util/object-utils.js");
const raw_node_js_1 = require("../operation-node/raw-node.js");
class ExpressionBuilder {
    #props;
    constructor(props) {
        this.#props = (0, object_utils_js_1.freeze)(props);
    }
    /**
     * Returns a {@link FunctionModule} that can be used to write type safe function
     * calls.
     *
     * The difference between this and {@link Kysely.fn} is that this one is more
     * type safe. You can only refer to columns visible to the part of the query
     * you are building. {@link Kysely.fn} allows you to refer to columns in any
     * table of the database even if it doesn't produce valid SQL.
     *
     * ```ts
     * await db.selectFrom('person')
     *   .innerJoin('pet', 'pet.owner_id', 'person.id')
     *   .select([
     *     'person.id',
     *     (qb) => qb.fn.count('pet.id').as('pet_count')
     *   ])
     *   .groupBy('person.id')
     *   .having(count('pet.id'), '>', 10)
     *   .execute()
     * ```
     *
     * The generated SQL (PostgreSQL):
     *
     * ```sql
     * select "person"."id", count("pet"."id") as "pet_count"
     * from "person"
     * inner join "pet" on "pet"."owner_id" = "person"."id"
     * group by "person"."id"
     * having count("pet"."id") > $1
     * ```
     */
    get fn() {
        return new function_module_js_1.FunctionModule();
    }
    selectFrom(table) {
        return new select_query_builder_js_1.SelectQueryBuilder({
            queryId: (0, query_id_js_1.createQueryId)(),
            executor: this.#props.executor,
            queryNode: select_query_node_js_1.SelectQueryNode.create((0, table_parser_js_1.parseTableExpressionOrList)(table)),
        });
    }
    /**
     * See {@link QueryCreator.withSchema}
     */
    withSchema(schema) {
        return new ExpressionBuilder({
            ...this.#props,
            executor: this.#props.executor.withPluginAtFront(new with_schema_plugin_js_1.WithSchemaPlugin(schema)),
        });
    }
    /**
     * This can be used to reference columns.
     *
     * ### Examples
     *
     * In the next example we use the `ref` method to reference
     * columns of the virtual table `excluded` in a type-safe way
     * to create an upsert operation:
     *
     * ```ts
     * db.insertInto('person')
     *   .values(person)
     *   .onConflict(oc => oc
     *     .column('id')
     *     .doUpdateSet({
     *       first_name: (eb) => eb.ref('excluded.first_name'),
     *       last_name: (eb) => eb.ref('excluded.last_name')
     *     })
     *   )
     * ```
     *
     * In the next example we use `ref` in a raw sql expression. Unless you
     * want to be as type-safe as possible, this is probably overkill:
     *
     * ```ts
     * db.update('pet').set({
     *   name: (eb) => sql`concat(${eb.ref('pet.name')}, ${suffix})`
     * })
     * ```
     */
    ref(reference) {
        return new raw_builder_js_1.RawBuilder({
            queryId: (0, query_id_js_1.createQueryId)(),
            plugins: this.#props.executor.plugins,
            rawNode: raw_node_js_1.RawNode.createWithChild((0, reference_parser_js_1.parseStringReference)(reference)),
        });
    }
}
exports.ExpressionBuilder = ExpressionBuilder;
